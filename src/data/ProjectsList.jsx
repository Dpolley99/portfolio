export const projects = [
  {
    title: "Hushed Ink on Paper",
    description: "A scalable blog platform built with Next.js and TypeScript, emphasizing performance, maintainability, and content flexibility. Tailwind CSS and ShadCN are used together to balance custom styling with reusable UI components, while Zustand manages shared frontend state. Sanity.io serves as a headless CMS, allowing non-technical users to publish and manage content independently, making the platform suitable for long-term growth and real-world use.",
    image: "/projects/project-05.jpg",
    tags: ["Next.js", "TypeScript", "Tailwind CSS", "ShadCN", "Sanity CMS"],
    link: "https://hushedinkonpaper.vercel.app/",
    github: "https://github.com/Dpolley99/hushedinkonpaper",
    featured: true,
    story: "Hushed Ink on Paper began from a simple, personal place. A friend of mine loves writing poetry, but had no real platform that felt like his. Social media felt noisy, generic blog platforms felt limiting, and anything custom seemed out of reach because he has zero programming knowledge. I decided to build something specifically for him—quiet, intentional, and flexible enough to grow with his writing.\n\nFrom the start, scalability was a priority. I did not want this to be a one-off blog that would need to be rebuilt the moment the content grew or the structure changed. That decision shaped almost every technical choice I made. This was also the project where I finally used Next.js successfully. I had attempted to learn it multiple times before and failed just as often. This time was different. With persistence, documentation, and some targeted help from AI when I was genuinely stuck, things eventually clicked. Once they did, the benefits—routing, performance, structure—felt immediately justified.\n\nOn the frontend, I used Tailwind CSS extensively with custom classes to retain full control over the visual language of the site. To avoid reinventing everything, I paired it with ShadCN for prebuilt, composable UI components. This balance let me move faster without sacrificing consistency. Zustand handled state management where global state made sense, continuing a pattern I had grown comfortable with in previous projects. I also chose TypeScript deliberately. For a content-heavy application like a blog, clarity, predictability, and long-term maintainability matter more than speed alone.\n\nThe most important architectural decision was the backend. I used Sanity.io so my friend could manage content independently. He can upload poems, edit text, and publish work without ever touching code or asking me to intervene. That separation—between content and implementation—was essential. It turned the project from “a website I built” into “a platform he can actually use.”\n\nHushed Ink on Paper is not flashy, and it was never meant to be. It is quiet by design. For me, it represents a shift toward building with intent: thinking about users who are not developers, planning for growth from day one, and choosing tools based on suitability rather than novelty. More than anything, it reflects a maturing approach to software—one where the system serves the person, not the other way around.",
  },
  {
    title: "EdgeAI SaaS Landing Page",
    description: "A React and Tailwind CSS landing page created to explore third-party state management solutions in a controlled scope. Zustand is used to implement global UI state for features such as theme toggling, demonstrating scalable and minimal state architecture without unnecessary abstraction. The project focuses on clean separation of UI state, reusable components, and maintaining development momentum through incremental experimentation.",
    image: "/projects/project-01.jpg",
    tags: ["React", "TypeScript", "Tailwind CSS", "Zustand"],
    link: "https://edgeaisaas.netlify.app/",
    github: "https://github.com/Dpolley99/Saas-landing-page",
    featured: false,
    story: "The Edge AI SaaS landing page was another React and Tailwind CSS project, but this time the objective was less about pushing technical limits and more about maintaining momentum. After completing a few projects in quick succession, I was conscious of not slowing down or slipping back into passive learning. This project was intentionally scoped to be manageable, but not disposable. I wanted it to serve as a learning vehicle rather than just another completed checklist item.\n\nTo keep things interesting, I introduced third-party tooling into the mix. I used Zustand for state management, primarily to implement a dark mode toggle across the application. Until this point, most of my state handling had been either local or relatively simple. Zustand stood out because of how lightweight and direct it felt compared to heavier alternatives. Setting it up forced me to think more carefully about global state, separation of concerns, and how UI decisions propagate across components.\n\nWhat started as a small experiment turned into a genuinely useful abstraction. The dark mode toggle was simple on the surface, but it highlighted how quickly state can become fragmented without a clear structure. Zustand made that complexity feel controlled rather than accidental. It also shifted how I think about future projects—particularly those with more interactive features or shared UI state—because it showed me that state management does not have to be over-engineered to be effective.\n\nIt was during this project that the idea of building my own portfolio became concrete. Working on yet another landing page made me reflect on presentation, consistency, and how projects are perceived when viewed as a collection rather than in isolation. Edge AI didn’t just add another entry to a list of projects; it influenced how I wanted to frame and showcase my work as a whole.\n\nWhile the project itself was not designed to be especially challenging, it served an important purpose. It reinforced the habit of continuous building, experimenting with new tools, and reflecting on long-term direction rather than short-term difficulty. Zustand, in particular, is something I would comfortably reach for again if a project demanded more complex state handling.\n\nEdge AI represents steady progress rather than a breakthrough—and that is precisely why it matters.To keep things interesting, I introduced third-party tooling into the mix. I used Zustand for state management, primarily to implement a dark mode toggle across the application. Until this point, most of my state handling had been either local or relatively simple. Zustand stood out because of how lightweight and direct it felt compared to heavier alternatives. Setting it up forced me to think more carefully about global state, separation of concerns, and how UI decisions propagate across components.\n\nEdge AI represents steady progress rather than a breakthrough—and that is precisely why it matters.",
  },
  {
    title: "MovieFlix - Mobile Movie App",
    description: "A React Native mobile application built with Expo that integrates the TMDB API for real-time movie search and trending content. The app includes navigation, authentication via Appwrite Auth, and persistent user-specific saved movies. This project combines API consumption, user state management, and backend integration, and was deployed as an Android APK, marking a full end-to-end mobile development workflow from build to installable release.",
    image: "/projects/project-02.jpg",
    tags: ["React Native", "TypeScript", "Expo", "Appwrite"],
    link: "https://expo.dev/accounts/not_deba/projects/mobile-movie-app/builds/c5f1326e-9d3e-44e1-936f-42a9cc808192",
    github: "https://github.com/Dpolley99/mobile-movie-app",
    featured: true,
    story: "Movieflix was my first React Native project, and easily the most exciting one I’ve built so far. More than the features themselves, this was the project that brought me back to programming after a long gap. In the beginning, everything felt slightly unfamiliar—mobile concepts, navigation patterns, tooling—but once the pieces started coming together, it reminded me why I enjoy building software in the first place.\n\nThis was also the first time I used GitHub and source control properly. Instead of treating version control as an afterthought, I committed changes consistently and treated the repository as a living record of progress. That alone changed how I approached development. I felt more comfortable experimenting, breaking things, and fixing them, knowing I always had a clean history to fall back on.\n\nI started by following a tutorial, but it quickly became clear that it was incomplete. The tutorial covered only the frontend and basic integration with Appwrite, taking the project up to the initial setup, home screen, navigation, search functionality, and connection to the TMDB API. This was my first time working with an external API, and seeing real movie data populate the app—especially the “Trending Movies” section driven by user searches—was a major turning point. The app stopped feeling like a mockup and started feeling like a real product.\n\nThis project also became my first real opportunity to use TypeScript. I had wanted to learn it for a long time, but never found a situation where the benefits felt obvious enough to justify the added complexity. Movieflix was that opportunity. Working with API responses, navigation props, and shared data structures made the value of TypeScript immediately clear. Type safety reduced guesswork, caught mistakes early, and forced me to think more deliberately about data flow. It was challenging at first, but it fundamentally improved how confident I felt working within the codebase.\n\nOnce the tutorial ended, I chose to continue on my own. I implemented user authentication using Appwrite Auth and added a “Saved” page where users could store their favourite movies. Finally, I deployed the app using Expo and generated an APK for Android devices. Movieflix is limited in scope, but that was never the point. It taught me skills I did not think I was capable of at the time, and I see it as a clear stepping stone toward serious mobile app development.",
  },
  {
    title: "Brainwave AI SaaS",
    description: "A dynamic SaaS landing page built with React and Tailwind CSS, designed to behave like a multi-section application rather than a static page. React Router DOM is used for section-based navigation, requiring careful coordination between routing, scrolling, and component rendering. The project incorporates scroll-driven interactions and parallax effects, implemented using custom Tailwind classes and React hooks such as useRef to manage DOM-level behavior and motion.",
    image: "/projects/project-03.jpg",
    tags: ["React", "JavaScript", "Tailwind CSS", "React Router"],
    link: "https://jolly-dolphin-cd317f.netlify.app/",
    github: "https://github.com/Dpolley99/Brainwave-AI-SaaS",
    featured: true,
    story: "The Brainwave AI SaaS landing page was my second serious project using React and Tailwind, and I approached it very differently from the first. After completing the HooBank landing page, I was no longer trying to prove that I could “get something working.” I was comfortable with the newer versions of React and Tailwind, and I wanted a project that would force me to think beyond static layouts and simple component composition.\n\nThis time, I deliberately introduced complexity. The project is still a single landing page in spirit, but it behaves more like a multi-page experience. I used React Router DOM to handle navigation between sections, which turned out to be far more challenging than I expected. Routing concepts felt unintuitive at first—especially when combined with scrolling behavior and section-based navigation. I broke things often. Links didn’t resolve correctly, scroll positions behaved unpredictably, and components re-rendered in ways I didn’t anticipate.\n\nReact Router DOM, in particular, was a steep learning curve. There were moments where nothing made sense, and quick fixes only created new problems elsewhere. Instead of stepping back, I leaned into the discomfort. I spent hours reading documentation, scanning Stack Overflow and Reddit threads, and testing small changes to isolate what was actually happening. When I genuinely hit a wall, I used AI selectively—not for answers to copy, but to help reason through bugs I couldn’t untangle on my own. Over time, the mental model started to click.\n\nBeyond routing, I pushed myself on interaction and motion. I implemented scroll-based effects and parallax behavior to give the page more depth and rhythm. That meant relying heavily on custom Tailwind classes rather than presets and using React hooks like useRef to interact directly with the DOM when necessary. These were small but important steps toward understanding how React manages state, references, and rendering under the hood.\n\nThis project wasn’t about visual polish alone. It was about learning how complexity compounds in frontend systems, and how patience and structure matter as much as creativity. Brainwave represents a shift in how I build: less tutorial-driven, more exploratory, and more willing to sit with problems until I genuinely understand them.",
  },
  {
    title: "HooBank Landing Page",
    description: "A responsive landing page built using React and Tailwind CSS, developed while adapting an older tutorial to modern tooling (React 19 and Tailwind v4). The project involved resolving breaking changes through official documentation and community research, rather than relying on copy-paste solutions. It was later extended with unit and integration tests using Jest and Vitest, alongside a lightweight CI/CD setup that enforces test-validated deployments, introducing disciplined development practices early.",
    image: "/projects/project-04.jpg",
    tags: ["React", "JavaScript", "Tailwind CSS", "Vitest"],
    link: "https://singular-wisp-85b08f.netlify.app/",
    github: "https://github.com/Dpolley99/Hoobank-modern-app",
    featured: false,
    story: "This project started as a deliberate step out of the “tutorial-only” comfort zone. The HooBank Landing Page was my first real attempt at building something tangible with React and Tailwind CSS after learning the fundamentals of HTML, CSS, and JavaScript. At the outset, the goal was simple: follow a YouTube tutorial end-to-end and understand how a modern frontend project is structured.\n\nThat plan became more interesting almost immediately. The tutorial I was following was built on React 18 and Tailwind v3.4, while I was working with React 19 and Tailwind v4. What initially looked like a minor version mismatch quickly turned into a practical lesson in how fast frontend tooling evolves. Things did not work out of the box, and blindly copying code was no longer an option. I had to slow down, read the official documentation carefully, and understand why certain configurations had changed rather than just what had changed.\n\nOver the next few days, the project became less about replicating a UI and more about problem-solving. I spent a significant amount of time reading documentation, comparing breaking changes, and digging through Stack Overflow threads to resolve issues that the tutorial never accounted for. Each fix felt incremental, but together they built confidence in navigating unfamiliar tooling without relying on step-by-step instructions.\n\nThe project itself is modest in scope—a landing page—but completing it took six focused days. That time wasn’t spent polishing visuals endlessly; it was spent learning how modern React projects actually behave in real-world conditions, where versions differ and assumptions break.\n\nAfter finishing the core build, I revisited the project with a different mindset. Instead of moving on, I treated it as a chance to introduce better engineering habits early. I added tests using Jest and Vitest and set up a small-scale CI/CD pipeline. Now, any change to the project only deploys if all tests pass. It’s not enterprise-grade infrastructure, but it reflects how I want to build software: intentionally, with safeguards, even when the project is small.\n\nThis project isn’t about perfection. It’s about learning how to adapt, debug, and finish—skills that matter far more than the complexity of the UI itself. HooBank laid the groundwork for how I approach every project since: with patience, curiosity, and a focus on understanding rather than just completing.",
  },
];